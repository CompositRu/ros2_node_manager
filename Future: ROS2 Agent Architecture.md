Отличный вопрос! Давай разберём эту гибридную архитектуру.

## Архитектура: Вебсервер снаружи + ROS2 Agent внутри Docker

```
┌─────────────────────────────────────────────────────────────────────────┐
│  Host (целевая машина)                                                  │
│                                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │  ros2-monitor (systemd service)                                   │  │
│  │                                                                   │  │
│  │  FastAPI + React                                                  │  │
│  │  ├── REST API                                                     │  │
│  │  ├── WebSocket                                                    │  │
│  │  └── UI статика                                                   │  │
│  │                                                                   │  │
│  │  Общение с Agent: TCP socket / Unix socket / HTTP                │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                              ▲                                          │
│                              │ Socket / HTTP                            │
│                              ▼                                          │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │  Docker: tram_autoware                                            │  │
│  │                                                                   │  │
│  │  ┌─────────────────────────────────────────────────────────────┐  │  │
│  │  │  ros2-agent (Python процесс)                                │  │  │
│  │  │                                                             │  │  │
│  │  │  import rclpy                                               │  │  │
│  │  │  ├── Подписка на /rosout (логи)                            │  │  │
│  │  │  ├── Мониторинг Hz топиков                                 │  │  │
│  │  │  ├── Получение списка нод/топиков                          │  │  │
│  │  │  └── Lifecycle управление                                   │  │  │
│  │  │                                                             │  │  │
│  │  │  Слушает: TCP :9090 или Unix socket                        │  │  │
│  │  └─────────────────────────────────────────────────────────────┘  │  │
│  │                                                                   │  │
│  │  ┌─────────────────────────────────────────────────────────────┐  │  │
│  │  │  ROS2 nodes (autoware)                                      │  │  │
│  │  │  /sensing/*, /perception/*, /planning/*, /control/*        │  │  │
│  │  └─────────────────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Сравнение подходов

### Текущий: docker exec

```
Запрос → Вебсервер → docker exec bash -c "ros2 ..." → Ответ
                     ↓
                     Каждый раз:
                     1. Создание процесса bash
                     2. Source ROS2 environment
                     3. Запуск ros2 CLI
                     4. Инициализация DDS
                     5. Discovery нод
                     6. Выполнение команды
                     7. Завершение процессов
```

### Гибридный: Agent внутри Docker

```
Запрос → Вебсервер → Socket → Agent → Ответ
                              ↓
                              Agent уже:
                              1. Инициализирован
                              2. Подключён к DDS
                              3. Знает все ноды
                              4. Подписан на топики
```

---

## Детальное сравнение

### ⏱️ Производительность

| Операция | docker exec | ROS2 Agent |
|----------|-------------|------------|
| Список нод | 1-2 сек | **<50 мс** |
| Информация о ноде | 2-4 сек | **<100 мс** |
| Параметры ноды | 2-5 сек | **<100 мс** |
| Topic Hz | 3+ сек (накопление) | **Мгновенно** (уже считает) |
| Topic Echo | 1-2 сек | **<50 мс** |
| Логи /rosout | Стрим работает | Стрим работает |
| Lifecycle transition | 1-2 сек | **<200 мс** |

**Вывод:** Agent в 10-50 раз быстрее для большинства операций.

### 💾 Ресурсы

| Аспект | docker exec | ROS2 Agent |
|--------|-------------|------------|
| RAM на команду | ~50-100 MB (временно) | 0 (Agent уже запущен) |
| RAM Agent постоянно | 0 | ~100-200 MB |
| CPU на команду | Высокий (init) | Низкий |
| Процессы | Много кратковременных | 1 постоянный |

**Вывод:** Agent экономит CPU, но требует постоянную RAM.

### 🔄 Реактивность (real-time данные)

| Функция | docker exec | ROS2 Agent |
|---------|-------------|------------|
| Логи | Стрим (уже работает) | Стрим (лучше, меньше задержка) |
| Hz топиков | Нужен отдельный процесс | **Push-модель** (Agent сам отправляет) |
| Состояние нод | Polling (каждые N сек) | **События** (Agent видит изменения) |
| Алерты | Delayed (ждём polling) | **Instant** (Agent реагирует сразу) |

**Пример push-модели для Hz:**
```python
# Agent внутри Docker
class TopicMonitor(Node):
    def __init__(self, websocket_callback):
        self.callback = websocket_callback
        self.hz_data = {}
    
    def monitor_topic(self, topic):
        # Подписываемся и считаем
        self.create_subscription(...)
    
    def timer_callback(self):
        # Каждую секунду отправляем Hz всех топиков
        self.callback({"type": "hz_update", "data": self.hz_data})
```

**Вебсервер получает Hz без запросов — Agent сам пушит.**

### 🛡️ Надёжность

| Аспект | docker exec | ROS2 Agent |
|--------|-------------|------------|
| Agent упал | Не влияет | ⚠️ Нужен restart |
| Autoware упал | Вебсервер работает ✅ | Вебсервер работает ✅ |
| DDS проблемы | Каждая команда отдельно | Agent может зависнуть |
| Изоляция | Полная | Agent внутри autoware |

**Вывод:** docker exec более изолирован, Agent требует мониторинга.

### 🧩 Функциональность

| Функция | docker exec | ROS2 Agent |
|---------|-------------|------------|
| Introspection (ноды, топики) | ✅ | ✅ |
| Параметры | ✅ | ✅ |
| Lifecycle | ✅ | ✅ |
| Topic Echo | ✅ (с ограничениями) | ✅ (проще фильтровать) |
| **Service Call** | ⚠️ Сложно | ✅ Легко |
| **Action Call** | ⚠️ Сложно | ✅ Легко |
| **Публикация в топик** | ⚠️ Сложно | ✅ Легко |
| **Запись rosbag** | ❌ | ✅ |

**Вывод:** Agent открывает больше возможностей.

---

## Плюсы ROS2 Agent

### 1. Скорость
```
Текущее:  User click → 2-5 секунд → Результат
С Agent:  User click → <100 мс → Результат
```

### 2. Push-модель для real-time данных
```python
# Agent сам отправляет изменения
agent.on_node_died(lambda node: websocket.broadcast({
    "type": "alert",
    "message": f"Node {node} died!"
}))

agent.on_hz_changed(lambda topic, hz: websocket.broadcast({
    "type": "hz_update",
    "topic": topic,
    "hz": hz
}))
```

### 3. Новые возможности

```python
# Service call (невозможно через CLI легко)
result = agent.call_service("/planning/set_goal", goal_msg)

# Публикация тестового сообщения
agent.publish("/test/cmd", test_command)

# Запись rosbag выбранных топиков
agent.start_recording(["/sensing/lidar/*", "/localization/*"])
```

### 4. Меньше нагрузка на систему
```
docker exec: 10 команд/сек = 10 процессов bash + 10 процессов ros2
Agent: 100 запросов/сек = 1 процесс обрабатывает всё
```

### 5. Точный мониторинг Hz
```python
# Agent считает сообщения напрямую
class HzCounter:
    def callback(self, msg):
        self.count += 1
    
    def get_hz(self):
        hz = self.count / self.elapsed
        self.count = 0
        return hz

# Точность: ±0.1 Hz
# docker exec ros2 topic hz: ±1-2 Hz (статистическая погрешность)
```

---

## Минусы ROS2 Agent

### 1. Ещё один компонент для деплоя
```
Было:     Вебсервер (1 бинарь)
Стало:    Вебсервер + Agent (2 компонента, синхронизация версий)
```

### 2. Agent должен быть внутри Docker
```yaml
# docker-compose.yml
services:
  tram_autoware:
    # ... существующий autoware
    # Нужно добавить agent или запускать отдельно

# Вариант 1: Добавить в entrypoint
# Вариант 2: Docker exec для запуска agent (один раз)
# Вариант 3: Sidecar контейнер с shared network
```

### 3. Связность с autoware
```
Если Agent зависнет → нужно перезапустить
Если Agent крашнется → теряем мониторинг до рестарта
Если autoware обновится → Agent может быть несовместим
```

### 4. Память постоянно занята
```
Agent: ~100-200 MB постоянно
vs
docker exec: 0 MB когда не используется
```

### 5. Сложность отладки
```
docker exec: Можно вручную выполнить ту же команду
Agent: Нужно смотреть логи Agent, сложнее воспроизвести
```

### 6. Протокол общения
```
Нужно разработать:
├── Формат сообщений (JSON-RPC? Protobuf? Custom?)
├── Обработку ошибок
├── Reconnect логику
└── Версионирование API
```

---

## Гибридный подход (рекомендация)

```
┌─────────────────────────────────────────────────────────────────────────┐
│  Что оставить на docker exec:                                           │
│  ├── docker ps, start, stop (управление контейнером)                   │
│  ├── Редкие операции (lifecycle transition)                            │
│  └── Fallback если Agent недоступен                                    │
│                                                                         │
│  Что перенести в Agent:                                                 │
│  ├── Логи /rosout (постоянный стрим)                                   │
│  ├── Hz мониторинг (постоянный)                                        │
│  ├── Topic echo (по запросу)                                           │
│  └── Быстрый introspection (ноды, топики)                              │
└─────────────────────────────────────────────────────────────────────────┘
```

### Протокол общения (простой вариант)

```python
# Agent слушает на Unix socket или TCP
# Формат: JSON-RPC like

# Request
{
    "id": "uuid",
    "method": "get_nodes",
    "params": {}
}

# Response
{
    "id": "uuid",
    "result": ["/node1", "/node2", ...],
    "error": null
}

# Push event (Agent → Вебсервер)
{
    "event": "node_died",
    "data": {"node": "/sensing/lidar/top/rslidar_node"}
}
```

---

## Сравнительная таблица

| Критерий | docker exec | ROS2 Agent | Гибрид |
|----------|-------------|------------|--------|
| Скорость | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| Простота деплоя | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |
| Надёжность | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| Real-time данные | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| Функциональность | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| Ресурсы | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| Отладка | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |

---

## Рекомендация по этапам

| Phase | Подход | Почему |
|-------|--------|--------|
| 1-2 | docker exec + кэширование | Быстрый старт, проверка концепции |
| 3 | + Agent для логов и Hz | Улучшение real-time мониторинга |
| 4 | Полный Agent | Масштабирование, новые функции |

**Сейчас:** docker exec достаточно для MVP и первых 10-50 устройств.
**Потом:** Agent имеет смысл когда нужны real-time алерты и новые функции.

---

Добавить это в документацию архитектуры как "Future: ROS2 Agent Architecture"?